{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ParsedStyles, ParsedStyle, GetStyleOptions, StyleConditions, Theme } from './types.js';\nimport { resolveProperty } from './aliases.js';\n\nexport type { ParsedStyles, ParsedStyle, GetStyleOptions, StyleConditions, Theme, Breakpoint, State, BreakpointStrategy, ThemeStrategy } from './types.js';\nexport { registerAlias, registerAliases, clearCustomAliases, getAllAliases, isAlias, DEFAULT_ALIASES, toKebabCase } from './aliases.js';\n\n// Builder API with IntelliSense support\nexport { StyleBuilder, createStyleBuilder, styleObject, getAliasHints, type CSSProperty, type PropertyAlias, type StyleObject } from './builder.js';\n\n// Integration utilities for other libraries\nexport { BreakpointIntegration, createIntegration, integrationUtils } from './integration.js';\n\nconst KNOWN_BREAKPOINTS = ['xs', 'sm', 'md', 'lg', 'xl', '2xl'];\n\n// Helper to compare two optional string arrays\nconst arraysEqual = (a?: string[], b?: string[]): boolean => {\n  if (a === undefined && b === undefined) return true;\n  if (a === undefined || b === undefined) return false;\n  if (a.length !== b.length) return false;\n  const sortedA = [...a].sort();\n  const sortedB = [...b].sort();\n  return sortedA.every((val, i) => val === sortedB[i]);\n};\n\n// Helper to check if all required states are present in current states\nconst statesMatch = (styleStates?: string[], currentStates?: string[]): boolean => {\n  // No states on style = matches anything\n  if (!styleStates || styleStates.length === 0) return true;\n  // Style has states but no current states provided = no match\n  if (!currentStates || currentStates.length === 0) return false;\n  // All style states must be present in current states\n  return styleStates.every(s => currentStates.includes(s));\n};\nconst BREAKPOINT_ORDER: Record<string, number> = {\n  'xs': 0,\n  'sm': 1,\n  'md': 2,\n  'lg': 3,\n  'xl': 4,\n  '2xl': 5,\n};\nconst KNOWN_STATES = ['hover', 'active', 'focus', 'visited', 'focus-visible', 'focus-within', 'disabled', 'enabled', 'checked', 'current'];\nconst KNOWN_THEMES = ['dark', 'light'];\n\n// Common CSS properties (not exhaustive, but covers most cases)\nconst KNOWN_CSS_PROPERTIES = new Set([\n  'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left',\n  'padding', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left',\n  'border', 'border-top', 'border-right', 'border-bottom', 'border-left',\n  'border-width', 'border-style', 'border-color', 'border-radius',\n  'width', 'height', 'min-width', 'min-height', 'max-width', 'max-height',\n  'display', 'position', 'top', 'right', 'bottom', 'left',\n  'flex', 'flex-direction', 'flex-wrap', 'flex-grow', 'flex-shrink', 'flex-basis',\n  'justify-content', 'align-items', 'align-content', 'align-self',\n  'grid', 'grid-template', 'grid-template-columns', 'grid-template-rows', 'grid-gap', 'gap',\n  'color', 'background', 'background-color', 'background-image', 'background-size', 'background-position',\n  'font', 'font-family', 'font-size', 'font-weight', 'font-style',\n  'text', 'text-align', 'text-decoration', 'text-transform',\n  'line-height', 'letter-spacing', 'word-spacing',\n  'opacity', 'visibility', 'z-index',\n  'cursor', 'pointer-events',\n  'overflow', 'overflow-x', 'overflow-y',\n  'transform', 'transition', 'animation',\n  'box-shadow', 'text-shadow',\n]);\n\n/**\n * Parses an enhanced style string with breakpoint, theme, and state prefixes.\n *\n * Format: ${arg1}:${arg2}:${argn}:${style-property}:${style-value};\n *\n * Args can be:\n * - Theme: dark, light, or custom theme names\n * - Breakpoint: xs, sm, md, lg, xl, 2xl, or custom breakpoints\n * - State: hover, active, focus, etc.\n *\n * @param input - Style string similar to HTML style attribute with optional prefixes\n * @returns Parsed styles object containing all style rules with their conditions\n *\n * @example\n * parse('color:red; dark:color:white; md:padding:20px; hover:dark:background:black')\n */\nexport const parse = (input: string): ParsedStyles => {\n  if (!input || typeof input !== 'string') {\n    return { styles: [] };\n  }\n\n  const styles: ParsedStyle[] = [];\n\n  // Split by semicolon to get individual style declarations\n  const declarations = input.split(';').map(s => s.trim()).filter(s => s.length > 0);\n\n  for (const declaration of declarations) {\n    // Split by colon to get all parts\n    const parts = declaration.split(':').map(p => p.trim());\n\n    if (parts.length < 2) continue; // Need at least property:value\n\n    // Strategy: work backwards to find where conditions end and property:value begins\n    // We need to find which parts are conditions and which are property:value\n    // Try to match known CSS properties by testing different split points\n\n    let property = '';\n    let value = '';\n    let conditionParts: string[] = [];\n    let found = false;\n\n    // Try different split points: last 2 parts could be property:value\n    // Or could be condition:value (if property is single-word)\n\n    // First, try assuming the last part is value and second-to-last is property\n    if (parts.length >= 2) {\n      const potentialValue = parts[parts.length - 1];\n      const potentialProperty = parts[parts.length - 2];\n\n      // Check if this could be a valid CSS property\n      if (KNOWN_CSS_PROPERTIES.has(potentialProperty)) {\n        property = potentialProperty;\n        value = potentialValue;\n        conditionParts = parts.slice(0, -2);\n        found = true;\n      }\n    }\n\n    // If not found, try matching multi-part properties (e.g., font-family from font:family)\n    if (!found && parts.length >= 3) {\n      for (let i = parts.length - 3; i >= 0 && i < parts.length - 1; i--) {\n        const potentialProperty = parts.slice(i, parts.length - 1).join('-');\n        if (KNOWN_CSS_PROPERTIES.has(potentialProperty)) {\n          property = potentialProperty;\n          value = parts[parts.length - 1];\n          conditionParts = parts.slice(0, i);\n          found = true;\n          break;\n        }\n      }\n    }\n\n    // Fallback: assume second-to-last part is property, last is value\n    if (!found && parts.length >= 2) {\n      property = parts[parts.length - 2];\n      value = parts[parts.length - 1];\n      conditionParts = parts.slice(0, -2);\n      found = true;\n    }\n\n    if (!property || !value || !found) continue;\n\n    const conditions: StyleConditions = {};\n    const states: string[] = [];\n\n    for (const condition of conditionParts) {\n      // Categorize each condition\n      if (KNOWN_BREAKPOINTS.includes(condition)) {\n        conditions.breakpoint = condition;\n      } else if (KNOWN_STATES.includes(condition)) {\n        states.push(condition);\n      } else if (KNOWN_THEMES.includes(condition)) {\n        conditions.theme = condition;\n      } else {\n        // Unknown condition - try to infer or store as custom\n        // For flexibility, we'll assume custom themes, breakpoints, or states\n        // Priority: check if it looks like a breakpoint pattern, otherwise theme\n        if (condition.match(/^\\d+xl$|^[xsml]+$/)) {\n          conditions.breakpoint = condition;\n        } else {\n          // Default to theme for unknown conditions\n          conditions.theme = condition;\n        }\n      }\n    }\n\n    // Add collected states to conditions if any\n    if (states.length > 0) {\n      conditions.states = states;\n    }\n\n    // Resolve property alias to full CSS property name\n    const resolvedProperty = resolveProperty(property);\n\n    styles.push({\n      property: resolvedProperty,\n      value,\n      conditions,\n    });\n  }\n\n  return { styles };\n};\n\n/**\n * Extracts CSS styles that match the given context (theme, state, breakpoint).\n *\n * @param parsedStyles - The parsed styles object from parse()\n * @param options - Context options (theme, state, breakpoint, breakpointStrategy, themeStrategy)\n * @returns CSS style string with matching properties\n *\n * @example\n * const parsed = parse('color:red; dark:color:white');\n * getStyle(parsed, { theme: 'dark' }); // Returns: 'color: white;'\n *\n * @example\n * const parsed = parse('font-size:14px; md:font-size:18px; lg:font-size:24px');\n * getStyle(parsed, { breakpoint: 'lg', breakpointStrategy: 'mobile-first' });\n * // Returns: 'font-size: 24px;' (includes base + md + lg)\n *\n * @example\n * const parsed = parse('color:blue; dark:color:white');\n * getStyle(parsed, { theme: 'light', themeStrategy: 'fallback' });\n * // Returns: 'color: blue;' (falls back to dark theme if light doesn't exist)\n */\nexport const getStyle = (\n  parsedStyles: ParsedStyles,\n  options: GetStyleOptions = {}\n): string => {\n  const { theme, states, breakpoint, breakpointStrategy = 'exact', themeStrategy = 'strict' } = options;\n\n  const matchingStyles: Array<{ property: string; value: string }> = [];\n\n  // Get breakpoint index for strategy matching\n  const currentBreakpointIndex = breakpoint && BREAKPOINT_ORDER[breakpoint] !== undefined\n    ? BREAKPOINT_ORDER[breakpoint]\n    : -1;\n\n  for (const style of parsedStyles.styles) {\n    const { conditions } = style;\n\n    // Check if all conditions match\n    let matches = true;\n\n    // Handle theme matching based on strategy\n    if (conditions.theme !== undefined) {\n      if (themeStrategy === 'strict') {\n        // Strict: theme must match exactly\n        if (conditions.theme !== theme) {\n          matches = false;\n        }\n      } else if (themeStrategy === 'fallback') {\n        // Fallback: if theme is specified, try to match\n        // Priority: exact theme match > base > other theme fallback\n        // Only fallback to other themes if no base exists for this property\n        if (theme !== undefined && conditions.theme !== theme) {\n          // Check if there's an exact theme match for this property\n          const hasExactThemeMatch = parsedStyles.styles.some(s =>\n            s.property === style.property &&\n            s.conditions.theme === theme &&\n            s.conditions.breakpoint === conditions.breakpoint &&\n            arraysEqual(s.conditions.states, conditions.states)\n          );\n\n          // Determine if we should skip fallback and prefer base instead\n          let skipFallback = false;\n\n          if (hasExactThemeMatch) {\n            // Always prefer exact theme match\n            skipFallback = true;\n          } else if (states !== undefined && states.length > 0 && (!conditions.states || conditions.states.length === 0)) {\n            // States requested, but fallback style doesn't have them\n            // Prefer base over themed fallback in this case\n            const hasBaseAtSameLevel = parsedStyles.styles.some(s =>\n              s.property === style.property &&\n              s.conditions.theme === undefined &&\n              s.conditions.breakpoint === conditions.breakpoint &&\n              arraysEqual(s.conditions.states, conditions.states)\n            );\n            if (hasBaseAtSameLevel) {\n              skipFallback = true;\n            }\n          } else if (breakpoint !== undefined && conditions.breakpoint === undefined) {\n            // Breakpoint requested, but fallback style doesn't have it\n            // Prefer any base style over themed fallback without the requested breakpoint\n            const hasAnyBase = parsedStyles.styles.some(s =>\n              s.property === style.property &&\n              s.conditions.theme === undefined &&\n              arraysEqual(s.conditions.states, conditions.states)\n            );\n            if (hasAnyBase) {\n              skipFallback = true;\n            }\n          }\n\n          if (skipFallback) {\n            matches = false;\n          }\n          // Otherwise, allow it as a fallback to other themes\n        } else if (theme === undefined && conditions.theme !== undefined) {\n          // No theme specified, but style has a theme - skip it even in fallback mode\n          matches = false;\n        }\n      }\n    }\n\n    // If style has states condition, all must be present in requested states\n    if (!statesMatch(conditions.states, states)) {\n      matches = false;\n    }\n\n    // Handle breakpoint matching based on strategy\n    if (conditions.breakpoint !== undefined && breakpoint !== undefined) {\n      const styleBreakpointIndex = BREAKPOINT_ORDER[conditions.breakpoint];\n\n      if (styleBreakpointIndex !== undefined && currentBreakpointIndex !== -1) {\n        // Known breakpoints - apply strategy\n        if (breakpointStrategy === 'exact') {\n          // Exact match only\n          if (conditions.breakpoint !== breakpoint) {\n            matches = false;\n          }\n        } else if (breakpointStrategy === 'mobile-first') {\n          // Include styles from current breakpoint and below\n          if (styleBreakpointIndex > currentBreakpointIndex) {\n            matches = false;\n          }\n        } else if (breakpointStrategy === 'desktop-first') {\n          // Include styles from current breakpoint and above\n          if (styleBreakpointIndex < currentBreakpointIndex) {\n            matches = false;\n          }\n        }\n      } else {\n        // Custom breakpoints - exact match only\n        if (conditions.breakpoint !== breakpoint) {\n          matches = false;\n        }\n      }\n    } else if (conditions.breakpoint !== undefined && breakpoint === undefined) {\n      // Style has breakpoint but no breakpoint provided - don't match\n      matches = false;\n    }\n\n    // If no conditions specified on the style, it always applies (base styles)\n    const hasConditions = conditions.theme !== undefined ||\n                         (conditions.states !== undefined && conditions.states.length > 0) ||\n                         conditions.breakpoint !== undefined;\n\n    if (!hasConditions) {\n      // Base style with no conditions - always include\n      matches = true;\n    }\n\n    if (matches) {\n      matchingStyles.push({\n        property: style.property,\n        value: style.value,\n      });\n    }\n  }\n\n  // Convert to CSS string format\n  // Handle multiple values for the same property by keeping the last one (CSS specificity)\n  const propertyMap = new Map<string, string>();\n\n  for (const style of matchingStyles) {\n    propertyMap.set(style.property, style.value);\n  }\n\n  const cssEntries = Array.from(propertyMap.entries())\n    .map(([property, value]) => `${property}: ${value};`)\n    .join(' ');\n\n  return cssEntries;\n};\n\n/**\n * Helper function for common dark/light theme pattern with automatic fallback.\n * Convenience wrapper around getStyle with themeStrategy: 'fallback'.\n *\n * @param parsedStyles - The parsed styles object from parse()\n * @param options - Options without themeStrategy (always uses 'fallback')\n * @param preferDark - If true, uses 'dark' theme; if false, uses 'light' theme (default: false)\n * @returns CSS style string with matching properties\n *\n * @example\n * const parsed = parse('color:gray; dark:color:white; light:color:black');\n *\n * // Use light theme with fallback to dark\n * getThemedStyle(parsed, {});\n * // Returns: 'color: black;'\n *\n * // Use dark theme with fallback to light\n * getThemedStyle(parsed, {}, true);\n * // Returns: 'color: white;'\n *\n * @example\n * // With breakpoints and states\n * const styles = parse('bg:blue; dark:bg:black; hover:opacity:0.9');\n *\n * getThemedStyle(styles, {\n *   breakpoint: 'md',\n *   state: 'hover'\n * });\n * // Automatically uses light theme with fallback\n */\nexport const getThemedStyle = (\n  parsedStyles: ParsedStyles,\n  options: Omit<GetStyleOptions, 'theme' | 'themeStrategy'> & {\n    theme?: Theme;\n  } = {},\n  preferDark: boolean = false\n): string => {\n  const theme = options.theme || (preferDark ? 'dark' : 'light');\n  return getStyle(parsedStyles, {\n    ...options,\n    theme,\n    themeStrategy: 'fallback'\n  });\n};\n"]}