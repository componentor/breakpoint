{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../src/helpers.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,UAAU,cAAc,CAAC,KAAiD;IAC/E,IAAI,CAAC,KAAK;QAAE,OAAO,EAAE,CAAC;IACtB,IAAI,OAAO,KAAK,KAAK,QAAQ;QAAE,OAAO,KAAK,CAAC;IAC5C,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QAC1B,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACvB,IAAI,OAAO,IAAI,KAAK,QAAQ;gBAAE,OAAO,IAAI,CAAC;YAC1C,OAAO,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC;iBACzB,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,IAAI,KAAK,EAAE,CAAC;iBACxC,IAAI,CAAC,IAAI,CAAC,CAAC;QACd,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACf,CAAC;IACD,OAAO,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;SAC1B,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,IAAI,KAAK,EAAE,CAAC;SACxC,IAAI,CAAC,IAAI,CAAC,CAAC;AACd,CAAC;AAID;;;;;GAKG;AACH,MAAM,UAAU,UAAU,CAAC,GAAG,MAAoB;IACjD,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,EAAE,CAAC;IACnC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAE1D,MAAM,QAAQ,GAA2B,EAAE,CAAC;IAE5C,yDAAyD;IACzD,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC7C,MAAM,UAAU,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QAC7C,IAAI,CAAC,UAAU;YAAE,SAAS;QAE1B,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACpC,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;YAC5B,IAAI,OAAO,EAAE,CAAC;gBACb,wDAAwD;gBACxD,4EAA4E;gBAC5E,uDAAuD;gBACvD,uDAAuD;gBACvD,MAAM,cAAc,GAAG,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;gBAChD,IAAI,cAAc,GAAG,CAAC,CAAC,EAAE,CAAC;oBACzB,sEAAsE;oBACtE,+CAA+C;oBAC/C,MAAM,GAAG,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,IAAI,EAAE,CAAC;oBACxD,MAAM,KAAK,GAAG,OAAO,CAAC,SAAS,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;oBAC3D,IAAI,GAAG;wBAAE,QAAQ,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;gBAChC,CAAC;YACF,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,OAAO,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;SAC7B,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,IAAI,KAAK,EAAE,CAAC;SACxC,IAAI,CAAC,GAAG,CAAC,CAAC;AACb,CAAC","sourcesContent":["/**\n * Normalizes adapt input to a string format\n */\nexport function normalizeAdapt(adapt: string | object | any[] | null | undefined): string {\n\tif (!adapt) return '';\n\tif (typeof adapt === 'string') return adapt;\n\tif (Array.isArray(adapt)) {\n\t\treturn adapt.map(item => {\n\t\t\tif (typeof item === 'string') return item;\n\t\t\treturn Object.entries(item)\n\t\t\t\t.map(([key, value]) => `${key}:${value}`)\n\t\t\t\t.join('; ');\n\t\t}).join('; ');\n\t}\n\treturn Object.entries(adapt)\n\t\t.map(([key, value]) => `${key}:${value}`)\n\t\t.join('; ');\n}\n\ntype AdaptInput = string | object | any[] | null | undefined;\n\n/**\n * Merges multiple adapt inputs\n * Left arguments override right arguments\n * @example mergeAdapt(child, parent) - child overrides parent\n * @example mergeAdapt(a, b, c, d) - a overrides b, b overrides c, c overrides d\n */\nexport function mergeAdapt(...adapts: AdaptInput[]): string {\n\tif (adapts.length === 0) return '';\n\tif (adapts.length === 1) return normalizeAdapt(adapts[0]);\n\n\tconst styleMap: Record<string, string> = {};\n\n\t// Process right-to-left so left args override right args\n\tfor (let i = adapts.length - 1; i >= 0; i--) {\n\t\tconst normalized = normalizeAdapt(adapts[i]);\n\t\tif (!normalized) continue;\n\n\t\tnormalized.split(';').forEach(prop => {\n\t\t\tconst trimmed = prop.trim();\n\t\t\tif (trimmed) {\n\t\t\t\t// Find the last colon that separates the key from value\n\t\t\t\t// Format: conditions:property:value (e.g., \"hover:dark:bg:red\" or \"bg:red\")\n\t\t\t\t// The key is everything except the final value segment\n\t\t\t\t// We need to find where the property:value boundary is\n\t\t\t\tconst lastColonIndex = trimmed.lastIndexOf(':');\n\t\t\t\tif (lastColonIndex > -1) {\n\t\t\t\t\t// The key is everything before the last colon (conditions + property)\n\t\t\t\t\t// The value is everything after the last colon\n\t\t\t\t\tconst key = trimmed.substring(0, lastColonIndex).trim();\n\t\t\t\t\tconst value = trimmed.substring(lastColonIndex + 1).trim();\n\t\t\t\t\tif (key) styleMap[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn Object.entries(styleMap)\n\t\t.map(([key, value]) => `${key}:${value}`)\n\t\t.join(';');\n}\n"]}